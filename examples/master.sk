import io;
import str;
import arr;
import os;
import fs;

struct Op {
  apply: Fn(Int, Int) -> Int
}

fn add(a: Int, b: Int) -> Int {
  return a + b;
}

fn main() -> Int {
  let i = 0;
  let acc = 0;
  while (i < 8) {
    i = i + 1;
    if (i % 2 == 0) {
      continue;
    }
    if (i > 7) {
      break;
    }
    acc = acc + i;
  }

  let x: Float = 8.0 / 2.0;
  if (x != 4.0) {
    return 90;
  }
  let nums: [Int; 4] = [1, 3, 5, 7];
  nums[1] = add(nums[0], nums[3]);
  let matchScore = 0;
  match (nums[0]) {
    1 | 2 => { matchScore = 5; }
    _ => { matchScore = 1; }
  }

  let f: Fn(Int, Int) -> Int = add;
  let via_f = f(4, 6);
  let ops: [Fn(Int, Int) -> Int; 2] = [add, f];
  let via_arr = ops[1](1, 2);
  let op: Op = Op { apply: add };
  let via_field = (op.apply)(2, 3);

  let xs: [Int; 5] = [7, 2, 9, 2, 5];
  let cnt2 = arr.count(xs, 2);
  let firstx = arr.first(xs);
  let lastx = arr.last(xs);
  let grid: [[Int; 2]; 2] = [[1, 2], [3, 4]];
  grid[1][0] = nums[1];

  let s = "skepa";
  let cwd = os.cwd();
  let platform = os.platform();
  let scratchRoot = fs.join(cwd, ".skepa_examples");
  let scratchDir = fs.join(scratchRoot, "master_tmp");
  let scratchFile = fs.join(scratchDir, "note.txt");
  os.sleep(1);
  if (str.len(cwd) <= 0 || str.len(platform) <= 0) {
    return 91;
  }
  if (fs.exists(scratchDir)) {
    return 93;
  }
  fs.mkdirAll(scratchDir);
  fs.writeText(scratchFile, "sk");
  fs.appendText(scratchFile, "epa");
  let scratchText = fs.readText(scratchFile);
  if (!fs.exists(scratchFile) || !str.contains(scratchText, "skepa")) {
    return 92;
  }
  if (scratchText != "skepa") {
    return 94;
  }
  fs.removeFile(scratchFile);
  fs.removeDirAll(scratchDir);
  let total = acc + nums[1] + grid[1][0] + 4 + str.len(s) + cnt2 + firstx + lastx + via_f + via_arr + via_field + matchScore;
  io.println("master example done");

  if (total == 78) {
    return 0;
  }
  return 1;
}
